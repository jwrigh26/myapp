Pages:

- overview of concepts
- practicie problems
- real-world applications
- cheat sheets
- whiteboard challenges

CS 101 How to pass the interview

algorithm and data structures

binary search
dfs & bfs
graphs
hashMaps
linked lists
recursion
sliding windows
sorts ( selective sort, merge sort, etc )
stack heaps
strings
trees

Those are the main folders I have so far, but I am not married to how I have things laid out. In fact I don't like it that much and wondering if you could help organize my content.

I am thinking 3 levels, main level would be like alogrithyms or data structures and under that would be sub topics like hash maps or sorting and then under there I would but routes to various pages related to said topic that i want to study.

Hoping you could provide some insight on what to remove, include, and how to organize so I can start to tackle the mountian of knowledge i need to start mastering for whiteboarding and computer science interview questions.

Concurrency vs parallelism vs multi-threading vs synchronization vs coordination

Here’s a polished version of your "Foundations" page navigation structure. I've refined headers, added relevant subheaders, and expanded placeholder pages with real-world inspiration to make the sections cohesive and comprehensive for your content.

---

### Foundations Page Drawer Navigation

#### **Math**: Core mathematical concepts foundational to computer science.

- **Asymptotic Notation**
  - Big-O, Big-Θ, Big-Ω
  - Growth Rate Comparisons
- **Modular Arithmetic**
  - Applications in Hashing
  - Modular Inverses
- **Complexity Analysis**
  - Analyzing Recursion Trees
  - Amortized Analysis
- **8th Grade Math**
  - Repeating Decimals
  - Roots and Radicals
  - Logarithms and Their Properties
  - Irrational Numbers and Approximations
  - Exponents and Powers
  - Scientific Notation and Applications
  - Linear Equations and Slope

#### **Recursion**: Mastering recursive techniques and patterns.

- **Basics**
  - Tail Recursion
  - Recursive Backtracking (e.g., Maze Solving)
  - Divide and Conquer Paradigm
  - Factorials and Fibonacci
- **Advanced Topics**
  - Memoization with Recursion
  - Recursion vs. Iteration
  - Power of Numbers (Efficient Exponentiation)
- **Applications**
  - DFS in Trees and Graphs
  - Generating Permutations
  - Solving Sudoku Recursively
- **D&D Recursion Fun** (for thematic and creative exploration)
  - Foo (Recursive Storytelling)
  - Bar (Building Recursive Worlds)
  - Dirp (Recursive Decision Trees)

#### **Strings**: Techniques and algorithms for string manipulation.

- **Fundamentals**
  - Understanding Character Sets (ASCII vs. Unicode)
  - String Immutability in Programming
- **String Algorithms**
  - Palindromes and Substring Palindromes
  - Longest Common Subsequence (LCS)
  - String Matching Algorithms (KMP, Rabin-Karp)
  - Anagram Detection
  - Regular Expressions: Basics and Applications
- **Applications**
  - Text Compression Techniques
  - String Tokenization and Parsing
  - Substring Search with Sliding Window

#### **Algorithms**: Key algorithms and their use cases.

- **Dynamic Programming**
  - Coin Change Problem
  - Longest Increasing Subsequence
  - Knapsack Variants
- **Searching**
  - Linear Search
  - Binary Search and Variants (e.g., Search in Rotated Arrays)
  - Exponential Search
- **Sliding Window**
  - Maximum Sum Subarray (Kadane’s Algorithm)
  - Longest Substring Without Repeating Characters
  - Minimum Window Substring
- **Sorting**
  - Bubble, Merge, Quick Sort
  - Counting Sort and Radix Sort
  - Heapsort
  - External Sorting (for massive datasets)

### **Data Structures**

- **Hashing**

  - Hash Functions and Collision Handling
  - HashMaps and HashSets
  - Applications: Caching and Deduplication

- **Linear Structures**

  - Arrays and Dynamic Arrays
  - Linked Lists (Singly, Doubly, Circular)
  - Stacks and Queues
  - Priority Queues

- **Non-Linear Structures**
  - Binary Search Trees (BSTs)
  - AVL and Red-Black Trees
  - Tries (Prefix Trees)
  - Segment Trees
  - Heaps: Min Heap, Max Heap, and Applications
  - Graphs: BFS, DFS, and Shortest Path Algorithms
  - Adjacency List vs. Matrix
  - BFS and DFS Traversals
  - Shortest Path Algorithms (Dijkstra, Floyd-Warshall)

---

This keeps all entries within two levels while still capturing the breadth of topics you want to cover. Let me know if you'd like further adjustments!
